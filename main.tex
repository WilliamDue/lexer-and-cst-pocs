% !TeX encoding = UTF-8 Unicode
\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage[english]{isodate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{centernot}
\usepackage{xfrac}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xcolor}
\usepackage{changepage}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{soul}
\usepackage{float}
\usepackage{centernot}
\usepackage{tcolorbox}
\usepackage{titling}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{etoolbox}
\usepackage{listings}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{titlesec}

\addbibresource{bibliography.bib}

\lstset{
  language=c++,
  numbers=left,                 
  numbersep=5pt,
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  commentstyle=\color{teal}\textit,
  keywordstyle=\color{purple}\bfseries,
}

\patchcmd{\section}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsection}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsubsection}{\bfseries}{\bfseries\boldmath }{}{}

\hypersetup{
  colorlinks=True,
  urlcolor=blue,
  citecolor=red,
  menucolor=black,
}

\renewcommand{\UrlFont}{\ttfamily\footnotesize}

\newcommand\defiff{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{\iff}}}
\newcommand\defeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{=}}}
\newcommand\concat{\: \mathrlap{+} \: +}
\newcommand\map{\textbf{map}\ }
\newcommand\reduce{\textbf{reduce}\ }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem*{remark}{Remark}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}
\newtheorem{algorithm}{Algorithm}[section]
\newtheorem{example}{Example}[section]
\DeclareMathOperator{\sign}{sign}

\fancyhf{}
\setlength{\headheight}{14.49998pt}
\pretitle{\vspace{-120pt}\begin{center}}
\posttitle{\par\end{center}\vspace{-80pt}}
\fancyhead[C]{}
\fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
\pagestyle{fancy}
\fancypagestyle{firstpage}{%
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
}
\title{
    {\Large \textsc{University of Copenhagen}} \\[0pt]
    {\large Computer Science Department} \\[10pt]
    {\Large Data-Parallel Compilation} \\[4pt]
    {\large Lexical analysis \& Syntax Tree Construction} \\[10pt]
    William Henrich Due (mcj284)  \\[0pt]
    Submitted: 5th of April 2024
}
\author{}
\date{}

\begin{document}
\maketitle
\thispagestyle{firstpage}
\begin{abstract}
    Abstract.
\end{abstract}

\section{Introduction}
Introduction.

\section{Theory}
Hills paper ``Parallel lexical analysis and parsing on the AMT
distributed array processor'' \cite{HILL1992699} describes a method to obtain the path in a deterministic finite automata given a input string. This section will describe the theory of this method and extend the it for tokenization.

% I should probably mention that pareas also uses this paper and does tokenization but I have no idea how they do it.
\subsection{Data-parallel Lexical Analysis}
To explain the theory of parallel lexical analysis we first remind the reader of the definition of a deterministic finite automaton.
\begin{definition}[DFA]
  A deterministic finite automata \cite{10.5555/1196416} \cite{enwiki:1192025610} is given by a 5-tuple $(Q, \Sigma, \delta, q_0, F)$ where.
  \begin{enumerate}
    \item $Q$ is the set of states where $|Q| < \infty$.
    \item $\Sigma$ is the set of symbols where $|\Sigma| < \infty$.
    \item $\delta: \Sigma \to Q \to Q$ is the transition function.
    \item $q_0 \in Q$ is the initial state.
    \item $F\subseteq Q$ is the set of accepting states.
  \end{enumerate}
\end{definition}
\noindent Note that this definition utilizes currying for the transition function $\delta$. This is done in the definition because if we have any two functions $g = \delta(a)$ and $f = \delta(a')$ then it follows from composition that for any $q \in Q$.
\begin{align*}
  g(f(q)) = (g \circ f) (q)
\end{align*}
This allows for an alternative way of determining if a string can be produced by an DFA. Instead of first evaluating $f(q)$, then $g(f(q))$ and then checking if this state is a member of $F$. We could instead partially apply $\delta$ to the symbols and then compose them to a single functions which could be used to determine if a string is valid. This sets the stage for data-parallel lexing, we want to find a way to make the problem into a \texttt{map-reduce}.



\begin{definition}
  A endofunction is a function $f:A \to A$ where the domain is equal to its codomain.
\end{definition}


\subsection{Parallel Tokenization}



\section{Conclusion}
Conclusion.
\printbibliography
\end{document}