% !TeX encoding = UTF-8 Unicode
\documentclass[a4paper,12pt]{article}
\usepackage[english]{babel}
\usepackage[english]{isodate}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{centernot}
\usepackage{xfrac}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{xcolor}
\usepackage{changepage}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{soul}
\usepackage{float}
\usepackage{centernot}
\usepackage{tcolorbox}
\usepackage{titling}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{etoolbox}
\usepackage{listings}
\usepackage{biblatex}
\usepackage{csquotes}
\usepackage{titlesec}

\addbibresource{bibliography.bib}

\lstset{
  language=c++,
  numbers=left,                 
  numbersep=5pt,
  basicstyle=\ttfamily\footnotesize,
  breaklines=true,
  commentstyle=\color{teal}\textit,
  keywordstyle=\color{purple}\bfseries,
}

\patchcmd{\section}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsection}{\bfseries}{\bfseries\boldmath }{}{}
\patchcmd{\subsubsection}{\bfseries}{\bfseries\boldmath }{}{}

\hypersetup{
  colorlinks=True,
  urlcolor=blue,
  citecolor=red,
  menucolor=black,
}

\renewcommand{\UrlFont}{\ttfamily\footnotesize}

\newcommand\defiff{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{\iff}}}
\newcommand\defeq{\mathrel{\stackrel{\makebox[0pt]{\mbox{\normalfont\tiny def}}}{=}}}
\newcommand\concat{\: \mathrlap{+} \: +}
\newcommand\map{\textbf{map}\ }
\newcommand\reduce{\textbf{reduce}\ }
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem*{remark}{Remark}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}
\newtheorem{algorithm}{Algorithm}[section]
\newtheorem{example}{Example}[section]
\DeclareMathOperator{\sign}{sign}

\fancyhf{}
\setlength{\headheight}{14.49998pt}
\pretitle{\vspace{-120pt}\begin{center}}
\posttitle{\par\end{center}\vspace{-80pt}}
\fancyhead[C]{}
\fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
\pagestyle{fancy}
\fancypagestyle{firstpage}{%
    \fancyhf{}
    \renewcommand{\headrulewidth}{0pt}
    \fancyfoot[R]{Page \thepage \hspace{1pt} of \pageref{LastPage}}
}
\title{
    {\Large \textsc{University of Copenhagen}} \\[0pt]
    {\large Computer Science Department} \\[10pt]
    {\Large Data-Parallel Compilation} \\[4pt]
    {\large Lexical analysis \& Syntax Tree Construction} \\[10pt]
    William Henrich Due (mcj284)  \\[0pt]
    Submitted: 5th of April 2024
}
\author{}
\date{}

\begin{document}
\maketitle
\thispagestyle{firstpage}
\begin{abstract}
    Abstract.
\end{abstract}

\section{Introduction}
Introduction.

\section{Theory}
Hills paper ``Parallel lexical analysis and parsing on the AMT
distributed array processor'' \cite{HILL1992699} describes a method to obtain the path in a deterministic finite automata given a input string. This section will describe the theory of this method and extend the it for tokenization.

% I should probably mention that pareas also uses this paper and does tokenization but I have no idea how they do it.
\subsection{Data-parallel Lexical Analysis}
To explain the theory of parallel lexical analysis we first remind the reader of the definition of a deterministic finite automaton.
\begin{definition}[DFA]
  A deterministic finite automata \cite{10.5555/1196416} \cite{enwiki:1192025610} is given by a 5-tuple $(Q, \Sigma, \delta, q_0, F)$ where.
  \begin{enumerate}
    \item $Q$ is the set of states where $|Q| < \infty$.
    \item $\Sigma$ is the set of symbols where $|\Sigma| < \infty$.
    \item $\delta: \Sigma \times Q \to Q$ is the transition function.
    \item $q_0 \in Q$ is the initial state.
    \item $F\subseteq Q$ is the set of accepting states.
  \end{enumerate}
\end{definition}
\noindent This definition is fine as is but we will need to reformualte it to develop data-parallel lexical analysis. We would want the definition to use a curried transition function. But for this to hold then the DFA would also have to be total.
\begin{definition}[Total DFA]
  A DFA $(Q, \Sigma, \delta, q_0, F)$ is said to be total if and only if
  \begin{align*}
    \delta(a, q) \in Q : \forall (a, q) \in \Sigma \times Q
  \end{align*}
  If a DFA is total we may use a curried transition function $\delta: \Sigma \to Q \to Q$.
\end{definition}
\noindent This is needed since else the the function would not be fully defined in the domains $\Sigma$ and $Q$.

The reason for doing so is because if we have any two functions $g = \delta(a)$ and $f = \delta(a')$ then it follows from composition that.
\begin{align*}
  g(f(q)) = (g \circ f) (q)
\end{align*}
This allows for an alternative way of determining if a string can be produced by an DFA. Instead of first evaluating $f(q)$, then $g(f(q))$ and then checking if this state is a member of $F$. We could instead partially apply $\delta$ to the symbols and then compose them to a single function which could be used to determine if a string is valid. This sets the stage for data-parallel lexing, we want to find a way to make the problem into a \texttt{map-reduce}. We want to do this because it can be computed using a data-parallel implementation unlike the normal way of traversing a DFA.

For the ability to use a data-parallel \texttt{map-reduce} we must have a monoidal structure. Here $\Delta$ is the set of all the composed partially applied $\delta$ functions needs to be closed under function composition.

\begin{proposition}[DFA Endofunction Closure]
  Given a total DFA and an associative binary operation $\oplus: (Q \to Q) \times (Q \to Q) \to (Q \to Q)$. Then the set of endofunctions $\Delta: Q^Q$ will be closed under $\star$. The set $\Delta$ is the set $\Delta_i$ in the recurrence relation with the smallest $i$ such that $\Delta_i = \Delta_{i + 1}$.
  \begin{align*}
    \Delta_1 &= \{\delta(a) : a \in \Sigma \} \\
    \Delta_{i + 1} &= \Delta_i \cup \{f \star g : f, g \in \Delta_i\}
  \end{align*}
\end{proposition}
\begin{proof}
  We will start by showing that a solution $\Delta$ exists. First note that the cardinality is monotonically increasing i.e. $\Delta_i \subseteq \Delta_{i + 1}$ since $\Delta_{i + 1}$ is a union of $\Delta_i$ and another set. Secondly note that since $|Q| < \infty$ then a finite amount of functions of the form $Q \to Q$ can exists. Since the set is bounded and increasing then at some point $\Delta_i = \Delta_{i + 1}$ and the smallest $i$ where it holds is the solution $\Delta$.

  For $\Delta$ to be closed under $\star$, then for arbitray $f, g \in \Delta$ it must hold that $f \star g \in \Delta$. Since $\Delta_1$ is the set of endofunctions that contructs $\Delta$ and $\star$ is associative then all elements of $\Delta$ can be expressed of the form.
  \begin{align*}
    \delta(a_1) \star \dots \star \delta(a_n) \in \Delta
  \end{align*}
  If all permutations with replacement of $\Delta_1$ of any sequence length are members of $\Delta$ then $\Delta$ would be closed under $\star$. Futhermore, it is known that $\Delta$ is finite so the sequences at some point $\Delta_i = \Delta_{i + 1}$ would only add new sequences but no new endofunctions. Therefore it suffices to show that if all sequences of length $k$ where $1 \leq k \leq i$ is a subset of $\Delta_i$ then $\Delta$ is closed under $\star$. This can be shown using a proof by induction.

  Base: $\Delta_1$ trivially holds since it only contains sequences of length one and they are the initial endofunctions.

  Step: Given $\Delta_i$ contains every sequence of length $i$ or less then we to show this implies that $\Delta_{i + 1}$ will contain every sequence of length $i + 1$ or less.

  By the induction hypothesis $\Delta_{i + 1}$ must contain every sequence of length $i$ or less due to $\Delta_i \subseteq \Delta_{i + 1}$. It remains to show that every sequence of length $i + 1$ is a member of $\Delta_{i + 1}$. It is known that a direct product of $\Delta_i$ is used in the definition of $\Delta_{i + 1}$ so $\{f \star g : f, g \in \Delta_i\} \subseteq \Delta_{i + 1}$. A direct product between sequences of length $1$ and $i$ will create every sequence of length $i + 1$ and therefore every sequence of length $i + 1$ is a member of $\Delta_{i + 1}$. Thereby $\Delta$ is closed under $\star$.
\end{proof}
\noindent Since $\Delta$ is closed under an arbitrary binary associative operations then it follows that $\Delta$ and function composition induces a monoidal structure.

\begin{corollary}[DFA Composition Monoid]
  DFA composition closure induces a semigroup which in turn induces the monoid $(\Delta \cup \{id\}, \circ)$ where $id: Q \to Q$ and $id(q) = q$.
\end{corollary}
\noindent Knowing this we can establish the following algorithm
\begin{algorithm}[Data-parallel Lexical Analysis]\label{algo:lex}
  It can be determined in $O(n)$ work and $O(\log n)$ span if a string can be produced by a DFA. First construct the total DFA $(Q, \Sigma, \delta, q_0, F)$ from the DFA.
  \begin{enumerate}
    \item Partially apply $\delta$ to every symbol in the input string such that it becomes a sequence of endofunctions.
    \item Reduce the endofunction into a single endofunction $\delta': Q \to Q$.
    \item Evaluate $\delta'(q_0)$ and determine if $\delta'(q_0) \in F$.
  \end{enumerate}
\end{algorithm}

\subsection{Data-parallel Tokenization}
For data-parallel tokenization we need to extent data-parallel algorithm \ref{algo:lex} will be needed to be extended. The idea will be to use a data-parallel \texttt{map-scan} instead since it will gives all the states. This is also the methods described in Hills \cite{HILL1992699} paper. The problem is we need to be able to recongnize the longest strech of symbols that results in a token. And we also need to restart the traversal of DFA if a final state is hit while no options to traverse further. To do so we will need the following definitions.
\begin{definition}[Total DFA with a Dead State]
Given a DFA it is made total with a dead state by defining a new set of states $Q' = Q \cup \{d\}$ where $d$ is the dead state. Additionally a new transition function $\delta'$ is defined.
\begin{align*}
  \delta'(a, q) = \begin{cases}
    d &  (a, q) \notin \text{dom}(\delta) \\
    \delta(a, q) & \text{otherwise}
  \end{cases}
\end{align*}
  
\end{definition}
\begin{definition}[Token Function]
  Given a DFA and a set of tokens $T$. The token function $\mathcal{T}: F \to T$ is a function that maps accepting states to some token.
\end{definition}

\begin{definition}[Safe Composition]
  Given a total DFA with a dead state, the safe composition $\oplus$ is defined as followed.
  \begin{align*}
    (f \oplus g)(x) =
    \begin{cases}
      q_0 & f(g(x)) = d \land g(x) \in F \\
      f(g(x)) & \text{otherwise} 
    \end{cases}
  \end{align*}
\end{definition}

\section{Conclusion}
Conclusion.
\printbibliography
\end{document}